> HeadFirst设计模式第一章

# 设计背景

我们有一个鸭子游戏的软件，其中会有很多种类的鸭子。每种鸭子具有不相同的能力。
首先鸭子需要有以下几种能力（1）叫shout（2）游泳swim（3）外观display

# 设计阶段

## 阶段1

设计抽象类Duck，Duck提供swim和shout的公共实现，由不同的子类实现display方法。

## 阶段2

现在需要鸭子可以飞，也就是需要提供一个fly方法给Duck，这时会考虑以下几种设计方式。

### 实现1

在Duck中添加fly方法，提供默认实现或者交给子类进行实现。

如果采用这种实现方式，现在有两种新的鸭子类型（橡皮鸭、模型鸭）。这两种鸭子都是不会飞的，结果我们提供了fly
接口，那么就会造成要么橡皮鸭会飞了，要么就需要我们在这两个子类中去重写fly方法（内部打印我不会飞）。并且模型鸭是不会叫的，那么它也需要重写shout方法。

### 实现2

上面采用继承的方式是不灵活的，那么我们考虑拆解，将fly和shout方法拆出来搞成FlyAble和ShoutAble 接口。之后需要叫的或者需要飞的就选择性的实现这两个接口。

（考虑老版的java接口，不具备default实现）
这种看似解决了上面的问题，橡皮鸭不用飞了，模型鸭也不用飞和叫了。但是会带来两种问题，我们使用两种不同的鸭子去做事的时候对应的基类是不同的，也就是不能使用多态了。
另外，比如这样会带来大量的重复代码，比如我们50种鸭子全是嘎嘎叫，突然要改成呱呱叫，那么就要改变50个类的相同的代码，无法代码复用。

### 实现3

三个设计原则
- 将不变的和变化的代码拆分开，不要混合到以前，不让变化的部分影响到不变的代码。
- 尽可能的使用组合，而不是继承。继承不会让类拥有运行时动态修改行为的能力。
- 面向接口变成，不要面向实现编程。

既然fly和shout是变化的，那么就将它们拆分出来，将其抽象为一种行为FlyBehavior和ShoutBehavior，这两个东西和Duck
没有任何关系，也就说Fly和Shout是两种独立的算法，它们各自拥有不同的算法族群。

我们通过组合的方式将FlyBehavior和ShoutBehavior和Duck组合到一起。这样可以运行时动态的改变鸭子的行为，提升灵活性。
添加setter方法，就可以在运行时改变鸭子的具体行为。
